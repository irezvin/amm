2022-08-27 Практические вопросы по таблице (аяксовое редактирование БД)

-   в списке столбцов из-за new 'RegExp' в выражении стоит таймер - нет "кеширования"
    ?   может, использовать cnew (caching new)?
    
        -   достаточно сложно отлаживать cacheability - я долго ковырялся
            
            class: ui.Paginator,
            in__numRecords: 'tbl.fetcher.response.totalRecords || 0'

            
            -   1) tbl.fetcher оказалось некешируемым, потому что 
                у таблицы вначале инициализировался компонент (tbl начинало
                возвращаться), и на тот момент свойства fetcher еще не было!

                то есть мы зависим от порядка инициализации ((
                решил только сделав, что у всех элементов свойство component
                инициализируется последним. А правильно ли это?
            
                ?   object.propertyAdded('propertyName')??? - давно думаю
                    
            -   2) response.totalRecords - не кешируемое, так как response 
                это обычный хеш (пришлось добавить !!)
                
        -   RegExp.exec с сабпаттернами возвращает массив, содержимое которого
            non-observable :( пришлось добавить !!
            
            new 'RegExp'(columnFilter.value, 'i')).exec(this.component.src.caption || this.component.src.id)!!
            
            !   пользователь фреймворка никогда не поймет, что так нужно сделать
        
>   twin view:
    +   синхронизация высоты строк:
        +   когда меняем ширину столбца, смотрим на высоту таблицы; если поменялась,
            пересинхронизируем высоту строк
    +   почему некоторые редакторы не 100% высоты?!
        i   потому что у mainTable стояла height: auto (точнее, некорректный
            height: initial), который не давал выставлять содержимое ячеек 
            под 100%
    +   делаем широкую колонку совсем узкой, пользуемся постраничником, - 
        рассинхронизируется ширина столбцов в фиксированной шапке, adjustColumns()
        не помогает -- помогает, я им неправильно пользуюсь --
            сделал, что всегда выставляется ширина колонки, даже если 
            наша больше или равна целевой
    -   синхронизация таблиц: как вариант, использовать resizeObserver и intersectionObserver,
        и если размеры таблиц по ширине (шапки/главной) или высоте (края/главной)
        расходятся, вызывать adjust...
-   выставляем размеры
    -   когда у таблицы появляются новые строки, то должны применяться размеры,
        если ширина столбцов не auto
        
        -   тут фундаментальная проблема

