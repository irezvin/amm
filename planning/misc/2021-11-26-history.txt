

                            История разработки Amm:
                                  часть I, или 

                       на что я потратил свыше 900 часов 
                        с сентября 2016 по декабрь 2021


TL;DR:

-   База: 2016 - 1 триместр 2017
-   Expression: с весны до конца 2017
    ("кроличья нора", в которой есть вторая "кроличья нора" - наблюдение за массивами 
    и Amm.Expression.Range)
-   Builder, Field, Form - первая половина 2018
-   Repeater и связанное с ним: авг.2018 - авг.2019 (ArrayMapper, Filter, Instantiator)
-   Remoter: 3й триместр 2019
-   Модель данных: 2020 (4 месяца работы)
-   Table, Drag and Drop: 2021

2016 // 71

    Сентябрь // 1
    
    -   Начал работать

    Октябрь, ноябрь // 49

    -   События, подписки
    -   View & Element
    -   Сделал Visual, Input, DisplayParent (так как надо для Annotated), Annotated
    -   Сделал Root
    -   Начал делать тесты с QUnit

    Декабрь // 21

    -   ObservableArray

        Сейчас это Array.
        Причина: для Select'а.
        Часть была сделана в роддоме.

2017 // 188

    Январь-февраль // 25

    -   ObservableCollection 

        Сейчас это Collection.
        Причина: в Array не хватало функций чисто для объектов.
        Часть писал в кафе по утрам, по дороге на работу.
        
    Февраль-март // 18

    -   DisplayParent, collection view

    Апрель // 12
    
    -   Amm.Selection extends Amm.Collection - хранит выбранные объекты
        для случаев вроде select / multiple select. Поддерживает те же порядок/состав,
        что и в предке; свойство selected синхронизируется с присутствием в подмножестве.
        Сейчас эта задача решалась бы легче при помощи ArrayMapperЖ, а тогда пришлось
        писать 20к кода.
        
    Май // 28
    
    -   Select "Triad" (Amm.Trait.Select, Amm.View.Abstract.Select, Amm.View.Html.Select)
    
    -   Checkbox & Radio "Triads" (довольно сложно, так как они должны координировать
        взаимодействие друг с другом)
    
    -   Amm.Trait.Component (с ним я вообще перемудрил, объекты могут динамически
        становиться или переставать быть компонентом и т.п.)
        
    -   На горизонте забрезжили Expressions для связи между разными составными частями
        компонентов. Изначально я думал обойтись только условными "путями", но потом 
        понял, что если их надо парсить, то всё равно нужно делать движок выражений,
        и если уж так, то почему бы ему не быть полноценным. Поэтому...
       
    Июнь: expression // 32
    
    -   операторы
    -   начало парсера
    
    Июль: expression // 25
    
    -   парсер
    -   операторы
    -   function handler (идея потом была использована в ofun'ах)
    
    Август: expression // 7

    -   writeProperty
    -   разное
    -   наблюдение за массивами: планирование
    
    Сентябрь: expression // 7
    
    -   наблюдение за массивами
    -   планирование range. Я понял, что для обозначения индекса или экземпляра
        элемента в range мне понадобится поддержка переменных в выражениях
        
    Октябрь: expression // 12
    
    -   varsProvider: класс операторов, в которых есть свои переменные; а также     
        expressionThis (поддержка концепции некого "this" в выражениях)
        
    -   для range также нужна была возможность наблюдать одновременно
        за множеством экземпляров массива при помощи одного выражения.
        Я решил создать "контексты", которые отвечают за состояние одного 
        и того же оператора, но независимы друг от друга. У нас нет расходов на парсинг
        и создание экземпляров операторов, и, как я предполагал, это будет требовать
        меньше памяти.
    
    Ноябрь: expression // 12
    
    -   Для поддержки "контекстов" (создание, удаление, переключение) пришлось
        дорабатывать множество операторов
        
    -   плюс я обнаружил, что когда у нас что-то в выражении упоминается два раза,
        например 'foo.bar + foo.bar', и foo.bar меняется с 1 на 2, 
        то срабатывают два change:  2 + 1 и потом 2 + 2, поскольку каждый оператор
        подписывается отдельно. Поэтому нужно было диспетчирезовать события 
        через expression (expression подписывается на одно свойство одного объекта
        только один раз, а наблюдающие операторы добавляются в очерердь)
        
    Декабрь: expression // 10
    
    -   Переключение контекстов, в т.ч. при получении событий (каждый контекст
        подписывался на свои события отдельно, и если Expression находился в одном
        контексте, а событие приходило для другого, нужно было переключаться)
        
    -   Наконец-то начал делать range
    
2018 // 219
    
    Январь: expression // 26
    
    -   Range (разные варианты: Condition и т.п.)
    
    Февраль // 12
    
    -   завершение Expression.Range (если Expression растянулся на 3 месяца, то работа,
        необходимая для наблюдения за массивами, растянулась еще на около 
        5 календарных месяцев, правда, отчасти из-за падения выработки; по часам это
        64 и 67, то есть сопоставимые затраты времени)
        
    -   StaticDisplayParent

    -   начал делать Builder (изначально он назывался Detector)
    
    Март // 14
    
    -   Builder (доделал до удовлетворительного состояния)
    
    -   доработка Checkbox & Radio: группы ограничиваются общим компонентом
    
    Апрель // 11
    
    -   планирование и начало Amm.Trait.Field
    
    -   Decorator, Translator (decorator может только в одну сторону, а transaltor
        обе, плюс возвращать сообщения об ошибках) для преобразования значений поля
        между изменяемым объектом и редактором
        
    Май // 15
    
    -   Decorator, Translator: завершение
    
    -   Translator: List, Error (для генерирования сообщений об ошибках)
    
    -   доработки Annotated для вывода ошибок, required и т.п. Label, caption, required,
        errors - еще с 2016 это, как предполагалось, будут аннотации
        
    Июнь // 17
    
    -   основная работа над Trait.Field
    
    -   Trait.Form
    
    Июль // 27
    
    -   Trait.Form: завершение работы
    
    -   "Post-form tasks" (доработки, мелкие и не очень)
    
    -   Repeater: первый заход - около половины времени
    
        -   планирование
        -   понял, что нужен ArrayMapper
        -   первая и неудачная попытка сделать ArrayMapper; планируем по-новой
    
    Август // 28
    
    -   ArrayMapper: новая реализация (используется до сих пор, на сейчас - по 2021)
    
    -   Доработки создания Element так, чтобы вместо options предоставлялся html element,
        и в этом случае builder его парсит
        
    -   поддержка Amm.Builder.Ref для того, чтобы ссылаться в конструкторе элементы 
        относительно позиции определния в дереве DOM
        
    Сентябрь // 12
    
    -   Amm.Expression.Sync; мы можем при помощи sync__<prop>: expr сихнронизировать
        разные свойства разных объектов, причем декларативно
    
    -   начало работы над Repeater. Планирование; стало понятно, что, кроме ArrayMapper,
        нужно три вспомогательных объекта: 
        -   Instantiator создает новые объекты;
        -   Filter позволяет выбирать не все объекты, а часть, по условию 
            (но для этого он должен подписываться на все!)
        -   Sorter позволяет задавать порядок в коллекции назначения            
        
    -   Amm.Instantiator (ранее Amm.Collection.Instantiator)
    
    Октябрь // 18
    
    -   Amm.Filter (условия; см. функцию Amm.MultiObserver.Filter.Condition.testValue)
    
    -   для разнообразия стал планировать Amm.Remote.Mapper, который является 
        rewrite engine для URLs; потом, в начале 2019, сделал на его базе UrlMapper
        для Avancore; сейчас (2021) Amm.Remote.Mapper в Amm еще нигде не используется.
        
    Ноябрь (много, потому что стал по утрам час-другой работать в офисе) // 31
    
    -   Amm.Filter - основная работа
    
    -   Amm.Sorter - первая треть работы
    
    -   Amm.Instantiator.Variants (т.к. фильтр выдавал значение с идентификатором
        совпавшего условия, его можно было использовать для выбора прототипа)
        
    -   Так как Filter и Sorter наблюдают за множеством свойств множества объектов,
        я вынес диспетчеризацию событий из Amm.Expression в Amm.WithEvents.DispatcherProxy
        
    Декабрь // 8
    
    -   завершение Amm.Sorter
    
    -   планирование Amm.Trait.Repeater

2019 // 130

    Январь, февраль, март // 1
    
    -   перерыв: 1 час планировал Repeater, но занимался, в основном, доработками
        Avancore - около 51 часа за 3 месяца)
    
    Апрель-май // 20
    
    -   начал пробное решение с использованием предполагаемого repeater (думал сделать
        клиент для MongoDB)
    
    -   возможность определять View внутри Element (Amm.Element.getDefaultView, 
        Amm.View.Html.Default)
        
    -   Collection - ассоциативный доступ (свойство, значение которого используется 
        как ключ; поддержка getByKey(foo), collection.k[key])
    
    -   Select: поддержка списков объектов (когда value у опции является объектом,
        а не строкой)
    
    Июнь // 20
    
    -   завершение работы над Amm.View.Html.Default
    
    -   клиент для MongoDB - закопал еще 7.5 часов, потом забросил
    
    -   отладка памяти и "зависших" подписчиков - сделал так, что после окончания тестов 
        практически вся память свободна
    
        -   в тестах предупреждать об оставшихся зареганных экземплярах,
            учитывать по-тестово
            
        -   перестал регистрировать все созданные элементы по умолчанию в Amm._items
        
        -   нашел баги с cacheability у Expressions (эта такая штука, которая, когда 
            мы не можем подписаться на onchange свойства, делает таймер)
        
    Июль // 0
    
    - перерыв (гостили месяц в Испании, обстановка не располагала к работе)
    
    Август // 11
    
    -   Builder extensions (data-amm-x плюс callback)
    
    -   Trait.Instantiator с поддержкой Amm.Instantiator.Variants
    
    -   Trait.Repeater (то есть, по сути, работа над Repeater'ом, если считать ArrayMapper
        её частью, заняла 12 календарных месяцев, из которых я 3 не работал, ну и там 
        в общей сложности явно больше 100 часов)
        
    Сентябрь // 21
    
    -   Remoter: Uri, RequestProducer
    
    -   example 9: select с фильтрацией - лаконичный пример возможностей 
        работы requestProducer'а
        
    -   example 10: data table с аяксом и сортировкой - не менее лаконичный пример
        комбинации RequestProducer и Repeater
    
    -   Instantiator/Repeater: начинаем писать тесты, доделываем фиксы
        
    Октябрь // 21
    
    -   Instantiator/Repeater: заканчиваем писать тесты, доделываем фиксы
    
    -   тесты и доработки Amm.Remote.Uri
    
    -   Fetcher: RunningRequest, Transport, Transport.Debug; доработки асинхронных
        тестов (TestUtils.runStory)
        
    Ноябрь // 27
    
    -   наводим порядок в scratch и структуре директорий (примеры переименовал в 
        examples/example/NN-descr.php; отдельные директории для build, tests и т.п.)
        
    -   избавился от параллельной с компонентами иерархии parent/child и понятия "path",
        это нигде на практике не применялось)
        
    -   example 11: to-do list (ghetto-saving при помощи fetcher'а) - всё равно довольно
        компактный (если 9 и 10 были на один экран, этот на 2)
        
    Декабрь // 10
    
    -   начало работы над объектами данных: планирование (довольно долго, 
        в несколько заходов); Model, Mapper, ModelMeta (тогда это было LifecycleAndMeta).
        
    -   начало работы над Transaction
    
2020

    Январь // 15
    
    -   работа над Transaction    
    -   доработки Expression: typeof, instanceof, new
    -   доработки инстанцирования элементов: не изменять передаваемый хеш options
        в конструкторе (я этим грешил)
    
    Февраль-март-апрель // 57
    
    -   основной объем над моделью данных. Мета-свойства, их поставщики, валидация,
        жизненный цикл; упрощенное наблюдение за моделью (если одно свойство меняется,
        вся модель перевычисляется); корректная последовательность действий при валидации
        и т.п.
        
    Май-сентябрь // 0 учтенных
    
    -   я делал решение на Amm - чекаут для электронного магазина - первое "рабочее" 
        решение, в котором задействовал практически всё, что было до этого написано.
        В процессе делались разные мелкие модификации. 
        
    -   плюс в июне я вынес php-код, определяющий зависимости и упаковывающий классы,
        в отдельный класс, который может использоваться для решений на базе Amm
        
    Сентябрь-октябрь // 28
     
    -   тесты и коммит доработок, которые были сделаны летом
     
    -   от скуки начал документировать Amm при помощи zim, втянулся в это и документировал
        около 13 часов, но осветил очень мало вещей
        
    -   разобрал все свои to-do и записи, закинул старые, выполненные и отмененные 
        (брошенные) в архив, рациональные идеи, которые не хочется бросать, вынес
        в отдельный список        
    
    -   Amm.createClass (идея возникла в ходе документирования)
    
    -   Amm.State - планирование, начало реализации (пока заброшено)
    
    -   Amm.Table - первый заход планирования
    
    Ноябрь // 0
    
    -   перерыв (доделывал решение по чекауту)
    
    Декабрь // 3
    
    -   Amm.View.Html.Expressions (довольно удобная штука - возможность отображать, правда,
        в одностороннем порядке, свойства и выражения текущего элемента на html, свойства
        стиля и атрибуты html-узла; заняла всего 3 часа в первоначальном варианте
        
    -   Планирование
    
    При том, что учтено всего 103 часа, год был достаточно продуктивным. Много было
    понято и сделано в ходе первого реального решения на Amm в production'е. Плюс за год
    была разработана модель данных, которую я смог применять на практике (хоть и с
    самодельным слоем persistence, поскольку Mapper не был к этому моменту готов).
    
2021

    Январь-февраль // 41
    
    -   Html.Template - планирование (которое ничем не продолжилось)
    
    -   Table: этапы 1 и 2 - простое решение с применением ArrayMapper и элементов
        столбцы/строки/ячейки. По сути интеграционное решение для всего, что я делал
        в предыдущее время; пример 12: таблица с редактированием
        
    Март // 16
    
    -   Amm.ObservableFunction ("ofun"). Поскольку таблица многокомпонентная, а у меня
        политика не-использования Expressions в базовом фреймворке (т.к. громоздко),
        я сделал механизм, работающий по принципу Amm.Expression.FunctionHandler:
        мы считаем значения динамически и тут же подписываемся на них; 
        те, которыми не воспользовались за последний прогон, выбрасываются.
        
    -   эта идея мне так понравилась, что я бросился делать супер-легкий реактивный
        фреймворк на яваскрипте и ofun'ах, jqrx; но потом стало понятно, что без 
        virtual dom мы много не сделаем, поскольку, например. нужно сохранять фокус
        и value полей ввода
        
    Апрель // 7
    
    -   Table: продолжение; игрался с jqrx, плюс это апрель, поэтому мало часов
    
    Май-август // 31 (какое-то время у меня не работал taskCoach, и учтено не всё время)
    
    -   Drag and drop: схему придумал в мае; базовое решение заняло 2-3 месяца; пример 13
    
    -   "наколеночное" решение resize и drag у таблицы, чтобы понять, куда двигаться
    
    -   Dimensions
    
    Сентябрь // 18
    
    -   Полноценное решение Amm.Trait.Table.DragDrop, Amm.View.Html.Table.DragDrop
    -   Amm.View.Html.SingleDimension
    
    Октябрь // 24
    
    -   в рамках работы над редактированием записей сделал пример 14 с тестовыми данными
        на 1000 строк
        
    -   из-за того, что таблица в 1000 строк и 8 столбцов инициализировалась и рендерилась
        10 секунд (20 на лэптопе в режиме пониженного энергопотребления) - ускорил вдвое
        
    -   Instantiator: сделал повторное использование экземпляров
    
    -   для тестирования редактирования записей сделал MemStor, имитирующий (слегка)
        http сервер и работающий через Amm.Remote.Transport.Debug
        
    -   начал делать поддержку Generic Reorder (теперь это Item Drag), обновил пример 13

    Ноябрь // 53
    
    -   доделал Item Drag, сделал тесты и т.п.
    
    -   Table.SimpleKeyboardControl (view & trait) для управления таблицей с клавиатуры
        на базе кода из примера 12
    
    -   снабдил тестами и закоммитил кучу изменений
    
    -   Paginator
    
    -   снабдил пример 14 persistence при помощи transactions
    
    -   начал дорабатывать Record, Mapper, DataCollection. Mapper унаследовал
        от Instantiator, это оказалось удобно
        
    -   поскольку я решил сделать 2021 год рекордным по учтенному времени, у меня цель 
        221 час в этом году - на 2 больше, чем 2018. Для этого, чтобы в декабре мне
        осталось только 30 часов (что оптимистично), я должен сделать 53 в этом. Так как
        сил писать больше нет, я сел вести летопись Amm, вооружившись архивом 
        из task coach, и потратил на это уже 3:40.
        
