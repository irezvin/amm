2018-07-14
==========

Клонирование элементов
----------------------

Осмысливание концепции


    В идеале мы делаем так:
    
        overrides = { 
            id: 'clonedElement' 
        };
        newElement = element.clone(overrides);
        
    и всё отлино работает дальше.
    
    Варианты для overrides:
    
        а)  mod__id: function() -> будет вызываться функция для изменения свойств клона
        б)  overrides := function, params -> вообще при клонировании вызывается функция
    
    Вопросы возникают 
    
        1)  с "глубоким" клонированием, когда у элемента есть внутренние 
            дети/элементы/displayChildren
            
        2)  с ассоциациями с клонируемым элементом
        
            -   подписчиками
            -   компонентом или коллекцией, куда входит клонируемый элемент
            -   ссылками на root и т.п.
            
        3)  с клонированием views
            -   как клонировать html-элементы?!
                -   если в них есть другие views, как их связывать с views клонируемых элементов?
                -   если в них есть views элементов, которые не были клонированы?
                -   куда потом "прививать" новые dom-ветки?
            
    Мысли навскидку
    
        -   Component и Composite всегда клонируют своих потомков
        -   Element.outClone (newElement, element) 
                <-  подписывается collection, чтобы потом добавить себе клона
                <-  подписывается view, чтобы, если наш элемент был клонирован, сделать клон себя
                    и дальше наблюдать за элементом  
        -   Перекрестные ассоциации и наблюдение за событиями внутри компонента интеллигентно 
            клонируются? А как это?
            
        -   Вариант А: "карта клонирования"
            -   Нам надо ПЕРЕД клонированием рекурсивно пройтись по дереву элементов и коллекций, 
                и пометить те, которые мы будем клонировать заодно - им мы присваиваем какую-то метку
            -   Затем мы создаем карту "исходный элемент <-> клон"
            -   Затем мы все ассоциации и обработчики событий в клонах переделываем так
                -   если ассоциация есть в карте, то заменяем её на клон
                -   если ассоциации нет в карте, то мы её удаляем
            
        -   Вариант Б: "установка свойств"
        
            -   У каждого trait есть метод exportForClone(), который создает часть прототипа 
                будущего клона
            -   clone := new Amm.Element(exportedProto);
                после полной инициализации элемента создадутся необходимывае внутренние связи
                
        -   Вариант В: банальное процедурное клонирование
        
            -   Element::clone вызывает _clone_<foo> методы, которые определяются в traits,
                после чего вызывает событие onClone
            -   properties, которые мы создаем при помощи createProperty, нужно где-то запоминать,
                и так же дублировать при клонировании - уфф, сложно
            -   Нужно как-то упростить клонирование коллекций и ассоциаций
            -   ...
            -   Обязательно сделать клонирование views, так как это может в принципе быть отдельно
                нужно
                    -   в идеале мы должны копировать кусок html-а, а затем клонировать все views, 
                        которые его acquired, и которые
                            а) будут и дальше ссылаться на прежний элемент
                            б) клонируют также и view
                

Сейчас я думаю о том, что клонирование самих элементов не так уж и нужно, 
достаточно клонирования views

                
                
Amm.Element:

    clone: function() {
        
        // The Most Stupid Way
        var res = new Amm.Element();
        Amm.override(res, this);
        res._amm_id = null;
        res._callOwnMethods('_clone_', this); // calls _clone_<foo> methods
        
        return res;
        
    },
    
    _clone_element: function(origin) {
        
    }

