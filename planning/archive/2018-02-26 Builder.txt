2017-02-26

Работа Builder'а

<node data-amm-v-class=".Visual">
    <node
        data-amm-id="foo" // element identifier
        data-amm-e='{"prop": "value", "prop2": "value2"}'
        data-amm-v='{"class": ".Input"}'
    >
    </node>
</node>

Общий принцип

    data-amm-id - это id элемента. Если у нескольких узлов одинаковый id, то они
        ссылаются на один элемент.
    data-amm-e - это свойства элемента в JSON. Желательно, чтобы был не больше одного; 
        два свойства с разными значениями выбрасывают исключение
    data-amm-e-prop - это свойство элемента prop (json)
    data-amm-e-prop_ - это свойство элемента prop (строка)
    data-amm-e-prop-subprop - это свойство элемента prop.subprop
        если мы два раза устанавливаем одно свойство с разными значениями, выбрасывается 
        исключение
    data-amm-v... - это аналогичный набор свойств View. При этом у View устанавливается
        указанный htmlElement.
    
    Как определяется, к какому элементу относится View, если data-amm-id не указан:
        а) единственный внутренний без id относится к тому же, что и внешний с id
        б) внешний без id относится к единственному внутреннему с id
        Несколько внутренних с/без id - к ним уже не относится
    
    Как определяются traits элемента    
        -   у View есть defaultTraits
        -   если у элемента есть свойство Traits, то defaultTraits не используются
        -   если есть ExtraTraits, то defaultTraits используются
        
Область действия ids
    
    глобальные ids назначаются, добавляя @ к id
    иначе id действует только внутри одного и того же элемента (либо внешней области).
    Например,
        <div data-amm-id="foo">
            <div data-amm-id="bar">
                <div data-amm-id="foo"> <!-- создаст еще один элемент с id=foo -->
                </div>
            </div>
        </div>
        
2017-02-28

Builder

    +   Amm.Element
        +   views - создаст представления; назначит traits
        +   extraTraits - traits, которые добавляются к тем, которые назначаются views
        +   убедиться, что nodes создаются иерархически
    >   сделать связывание views с узлами-элементами
        -   всегда начинаем с самых глубоких
            есть e - ищем v снаружи
                если не нашли, то печалька (( ругаемся
            есть v - ищем e снаружи
                если не нашли, создаём пустой элемент
            если есть id, то мы ищем еще среди "братьев"

2018-03-06 - сделана базовая функциональность
                
    +   создавать отдельный экземпляр Builder'а каждый раз
    +   не трогать уже обработанные элементы
    +   команда для последующей "очистки"
    +   возможность приписывать элементы верхнего уровня Root'у или другому компоненту
        +   осталось определить эти самые элементы
    +   возможность указать какой-то признак, чтобы сразу детектить элементы внутри?
        +   data-amm-build
        +   data-amm-dont-build
    +   глобальные id-ы
    +   ругаться, когда у нас есть элемент без View
        +   data-amm-warning
        +   Amm.Builder.showWarnings = silent | console | html
    X   namespacing
    +   тесты
        +   простой запуск
        +   повторный запуск
        +   связывание по id
        +   проблемы
        +   связывание по глобальному id
        +   передача "урожая" Root'у или другому компоненту

2018-03-17
    +   builder -  пофиксить случай, 
    
        view 
            view w/id, w/o e
            
        должен создаться общий элемент
        
        view
            view w/o id, w/o e
            
        должен создаться общий элемент
