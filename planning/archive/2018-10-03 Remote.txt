2018-10-03
==========

Amm.Remote

Идея была такая:

    -   один запрос в единицу времени (то есть нет очереди запросов)
    -   устанавливаем URL + args как свойство
    -   изменение текущего URL + args приводит к запуску запроса
    -   пока запрос выполняется, меняется его свойство "state" 
        (также "running"), и мы можем блокировать элементы управления (свойство locked)
    -   получение ответа или сообщения об ошибке приводит к изменению свойств запроса
        error, response
    -   если у нас сервер может возвращать разные виды ответов, можно использовать систему фильтров
        (например, преобразовывать ответы определенного формата в ошибки)
        
urlOnlyArgs: список аргументов, которые всегда передаются через URL, и не постятся

urlArgsPrefix: __url__ - его можно добавлять, если нам нужно передать один и тот же параметр
    и в get'е, и в post'е
        
argsUrlMap:
    
    foo/posts/{page}/ - если есть параметр page, будет использован этот URL
    foo/post/{id}/ - если есть параметр id, будет использован этот URL
    foo/posts/ - если нет параметров page и id, или есть оба параметра, будет этот
    
    также можно придумать более сложную схему проверок на определенные комбинации параметров,
    но, наверное, пока не нужно
    
!   кстати, это также является схемой работы будущего router'а в Avancore

Весь механизм преобразования Args в запрос будет в отдельном классе Request.Mapper.

Должна быть возможность использования Amm.Remote для простой работы с записями _до_ того, как
я сделаю Storage.

Для более сложных операций, таких, как работа с записями (в т.ч. параллельная) можно использовать
    объект еще более высокого уровня, такой, как Storage (но нам будет нужен также такой trait, 
    как Record)
    
    load(id[s]) // returns one or many records
    validate(data[, id]) // validates record; id is omitted = for saving
    save(data[, id]) // creates (id is omitted) or modifies record
    delete(id[s]) // deletes one or many records
    list(filter, sort) // returns IDs matching criteria
    find(filter, sort) // returns records matching criteria
    count(filter)
    deleteMany(filter)
    updateMany(data[, filter])
    
Storage отвечает за корректное управление очередью запросов, например, 
-   validate/save/delete разных записей можно выполнять параллельно
-   операции с одной и той же записью нельзя выполнять параллельно
-   list, find, count будут дожидаться завершения выполнения всех операций по изменению
    записей
    
Потребители данных (таблицы, редакторы списков, редакторы отдельных записей) должны уметь
работать со Storage и корректно реагировать на результат операций validate, save, delete.

Например, коллекция может скрыть запись сразу после запроса на удаление, а потом показать её 
снова, если удалить не получилось.

По теории, вся функциональность по работе со Storage может быть представлена тремя Traits 
(Record, RecordEditor, ListEditor).
