2019-09-17

Контрольная точка, после которой можно "перевести дух"

+   можно вывести таблицу
+   можно фильтровать записи в таблице
+   remote: get, post
+   можно создавать записи при помощи POST'а // done @17.11

2019-09-19

X   проблема: если есть два элемента с одним data-amm-id, то возникает конфликт
    (а не должен!) -- ошибка была в том, что у них не было data-amm-e
    
+   Amm.Element: expr__<name> - создает property, которая на самом деле expression,
    и она read-only или read-write в зависимости от характера expression. При этом
    создается внешнее событие out<name>Change, что позволяет подписываться на события.
    
    exprs в options constructor'а имеют аналогичный эффект.
    
    // done @06.11
    
+   сделать, чтобы Select.setOptions, по возможности, сохранял выделенные элементы
    +   тест: что при этом не производим лишние события valueChange
    
+   scratch8 server-side autocomplete: вообще какая-то жесть происходит
    1)  non-cacheable expression this.fetcher.request, this.fetcher.request.uri::q
        стоят на таймере, при этом в них нет non-cacheable операторов! что за фигня
    2)  событие изменения uri тоже инициируется по таймеру какого-то выражения, 
        при этом в таймере его, кажется, нет
    3)  при возвращении value select'а после setOptions() событие setValue() генерируется 
        много раз (добавляется по одной опции) -- вообще пиздец
    4)  у нас вообще полностью зацикливаются запросы, поскольку uri меняется много раз (((
        может, сравнивать с последним запросом, на который был получен ответ, и если он 
        совпадает, не перезапрашивать?

2019-09-25

-   вопросы по scratch9

    -   сделать обертывание в Elements, убедиться, что вся таблица не висит на таймере
    -   сделать, чтобы expressions могли реагировать на событие onPropertiesChange (так как
        если мы добавляем свойство позже, expression уже на него не среагирует)
    -   обязательно нужно сделать repeater + repeater (строки + столбцы). 
    -   не хватает возможности определять повторно используемые прототипы (прото-классы)
        в builder'е
    -   не хватает возможности указать компонент-предок при помощи ссылки на элемент более
        высокого узла в builder'е (пока это всё делается через views)
    
2019-09-29

TODO на ближайшее время:

+   сделать expr__ (@2019-09-19) <- плюс переделать scratch8 и scratch9 // done @06.11
-   сделать onPropertiesChange (@2019-09-25)
+   проверить, чтобы expressions отписывались с таймера, когда они начинают кешироваться,
    и записывались обратно, когда прекращают
        +   expressionInstance.getWatchers() // getNonCacheableOperators(recursive)
        +   static Amm.Expression.getAllWatchers()
        +   проверить, почему у нас висят на таймере expressions в scratch8.php
            i   поскольку результат - обычный массив javascript, он заведомо некешируемый
                (NON_CACHEABLE_CONTENT), и его нужно наблюдать на предмет изменений
                (было исправлено при помощи модификатора кешируемости "!!", а вообще - 
                нужны обертывания)
        +   тест // done@07.11.2019
+   тесты для всего, что я наковырял за это время // done @03.11

2019-10-10

-   невозможно сделать фильтр, в котором expression condition
    бы возвращало свое собственное значение!! а так было бы просто преобразовывать значение
    какого-либо свойства напрямую в значение match
    
        f = new Amm.MultiObserver.Filter({
            conditions: [
                {_expr: 'this.a'},
            ]
        });    
        
        var e = new Amm.Element({prop__a: 'aVal'});
        
        f.getMatch(e); // returns 1; should return 'aVal'
       
2019-10-14

-   сделать, чтобы расширения (data-amm-x) могли останавливать рекурсивную работу builder'а
    (чтобы не нужно было писать data-amm-dont-build)

2019-10-26

+   Доработки Amm.Remote.Fetcher

    +   state: навести порядок
            warm or waiting = running (getRunning() === true)
        
        -   configuring - конфигурация не полная
        -   bootstrapping - будет запущен, когда Amm инициализируется
        -   idle - сконфигурирован, но не запущен
        -   waiting - запрос будет инициирован по таймауту
        -   sent - запрос был отправлен, ожидается ответ от сервера 
        -   received - был получен ответ на запрос
        -   error - была получена информация об ошибке
        
        как вернуться из error или received в idle: нужно в состоянии received 
            сделать setResponse(undefined), в состоянии error сделать setError(undefined),
            или в любом состоянии сделать reset()

    +   setConstRequest()
    +   setTransport()

