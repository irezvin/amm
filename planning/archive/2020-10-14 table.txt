2020-10-14
----------

Таблица

-   коллекция столбцов
    -   строки заголовка (по умолчанию - одна строка, выводящая названия столбцов)
    -   строки подвала (по умолчанию - нет)
-   коллекция строк данных

Столбцы:
    -   индекс
    -   скрыт/показан (если скрыт, рендерится, но скрывается средствами html'а)
    -   включен/отключен (если отключен, не рендерится и не обрабатывается)
    
Специальный столбец "заголовки строк", всегда первый.
Специальные строки "заголовки", "подвал".
    
Строки:
    -   индекс
    -   запись данных
    -   скрыта/показана (если скрыта, рендерится, но скрывается средствами html'а)
    -   включена/отключена (если отключена, не рендерится)
    -   статус записи: изменена; некорректна; есть серверные ошибки; в процессе транзакции
    -   аннотации об ошибках (А где их выводить?)
    -   у каждой строки есть ящики "внизу" и "вверху", где могут выводиться любые визуальные
        компоненты. Ящики могут быть скрыты/показаны. Они будут занимать всю ширину таблицы
        и выводиться между строками данных.
    
Адрес ячейки: id строки + id столбца.
Фокус: всегда комбинация строки/столбца.
Выделение:
    любое количество элементов, если не оговорено иное
    -   ячеек данных
    -   строк (выделение заголовка строки приводит к выделению строки)
    -   столбцов (выделение заголовка столбца приводит к выделению столбца)
    
Items: если ставим, то строки данных заполняются указанными элементами (array mapper).

Editor: текущий редактор, если он один.

EditorPresets:
    -   {editorOptionsId: editorOptions}

CellInformation:
    -   address (row, column)
    -   value    
    -   editable
        -   editorOptionsId
        -   editorOptions
        -   changed
        -   originalValue
    -   errors (если есть инфа об ошибках)

DefaultColumnOptions

Column:
    -   cellOptions
        -   getter
        -   editorOptionsId
        -   editorOptions
            -   setter/validator/translator
    -   headerOptions
        -   sortable
            -   currentSortDirection: undefined|asc|desc
        -   resizable
        -   draggable
        -   toggleable - пользователь может включать/выключать эту колонку в списке колонок
        -   headerControls (idx => control)
        -   footerControls (idx => control)
            
            
Editor
    -   show (cell)
    -   hide
    -   outConfirm
    -   outCancel
    -   outNavigationIntent (left, right, up, down) 
        - когда действия пользователя в редакторе должны интерпретироваться как попытка перейти
            в другую ячейку (например, дошел до конца поля редактирования и нажал вправо)
            
У таблицы есть outCellInformationCallback(row, column), когда мы получаем инфу о ячейке. Если инфа
не заполнена, испольуются умолчания столбца. Этот callback происходит либо при изменении ячейки
(появлении/исчезновении/модификации строки либо столбца), либо при изменении данных (если это
модель - то onAnyChange).

Аналогично есть outCellValueCallback(row, column, valueObtainedByGetter), плюс события для
редактирования ячеек.

Потенциально можно сделать копирование/вставку.

Так как я описал здесь очень много всего, может быть, есть смысл работать поэтапно.

2021-01-09
----------

-   Таблица содержит несколько DisplayParent'ов

    contextMenu
    editor
    columnInstance.editor
    activeRowDrawer
    rowInstance.drawer
    columnInstance.header
    serviceRowInstance.serviceCellInstance
    
    В любом из этих displayParent'ов можно размещать views или элементы

?   Как организовать обновление таблицы?

    -   создание строки: в цикле опрашиваем столбцы
    -   изменение ячейки: обращаемся к столбцу с просьбой обновить инфу по ячейке
    -   поменяли местами столбцы: в цикле приводим всё в соответствие (кто?)
    
-   Есть смысл у столбцов сделать свои views.

-   Каждый столбец наблюдает каждую запись и реагирует на её события (ему надо следить за всеми
    properties или expressions X все видимые строки).
    
2021-01-11
----------

-   Если сделать Rows "display children" таблицы...то

    -   у нас есть Array mapper, преобразующий items в item rows
    -   нам надо разбавлять item rows со спецстроками:
        -   header rows
        -   rows of items
        
            -   optional above-rows
            -   if item is active, above-active row
            -   item row
            -   if item is active, below-active row
            -   optional below-row
            
        -   footer rows
        
        ?   возможно, нужно объединять эту всю фигулень в itemRowGroup, 
            и делать верхние, строку и нижние её потомками, тогда у нас
            при перестроении будет двигаться вся группа
            
            X   но если мы будем корректно map'ать, то промежуточные parent'ы нам и не нужны
        
    -   itemRow
    
        hasAboveRow
        hasBelowRow
        isActive
        index
        
    -   when anything above in itemRow changes, remapping algo is ran
        
    -   drawerRow
    
        spans most of columns (either all columns or data columns)
        
-   Я боюсь, что это всё будет адски тормозить, но при этом нет других идей, и цель 
    оправдывает срдства (таблица это по-любому сложное решение; нужн сделать, что
    без "прибамбасов" типа drawers она всё равно будет корректно работать, просто 
    требовать меньше объектов в памяти)
    
2021-01-12+
-----------

Этап 1. Требования: // done@02.02

    +   служебные строки вверху (в первую очередь, строка заголовка и вторая строка
        с произвольными control'ами, которая может использоваться для фильтров)
    +   расчет содержимого колонок
    +   вывод строк и ячеек
    +   возможность скрывать/показывать столбцы, менять их порядок
    
    #   интерфейса для отображения, порядка, resize еще нет (как и ширины столбцов),
        но как минимум в описаном выше объеме программная часть работает -- 24.01        
    
Порядок действий
    +   mapper items -> rows
    +   column: подписка/отписка; обновление ячеек // d@18.01
    
        @13.01:
        
        .   логичным выглядит, что cell наблюдает/подписывается/отписывается, 
            а также знает, при помощи какого view себя выводить. Но это относится 
            только к ячейкам данных. То есть бывают разные ячейки? Например, 
            в спецстроках мы можем задавать параметры ячеек для разных столбцов.
        
        .   Поэтому у нас есть в строке параметр, который сообщает, к кому обращаться
            за прототипами ячеек: к столбцам или к строке.
        
        .   Точнее, он всегда обращается к строке, но строка по умолчанию перенаправляет
            к столбцу.
            
        X   Amm.Instantiator.ProtoCallback extends Amm.Instantiator.Proto
            
            onGetProto: function(proto, object)
                
    X   specialRows collection - у меня есть Amm.Table.Section   
    X   при изменении релевантных свойств мы перестраиваем коллекцию строк
    
    !   view
        -   @17.01: 
            Amm.View.Html.DisplayParent не создает для потомков представления по умолчанию;
            исправил каким-то дурацким кандибобером

2021-01-24
----------
        
+   Сделать удобные члены: // d@25.01
    +   table: items, columns, header, body, footer
    +   section: rows, table
    +   row: cells, section, item
    +   cell: row, column, item

+   Сделать  // d@26.01
    +   colgroup - сделал, а зачем?!!
    +   column.cellClassName
    +   cell.ignoreColumnCellClass
    +   cell.className will be dependent on 
        column.cellClass, 
    +   column.width
    +   column.className
    +   column.visible, влияет на cells?
    +   row.enabled, отрисовка только enabledRows
    
+   Сделать события, конфигурирующие строки и ячейки

+   Тесты

    +   корректный состав строк, ячеек
    +   порядок ячеек совпадает с порядком столбцов
    +   поменять порядок столбцов, проверить
    +   порядок строк совпадает с порядком item'ов
    +   поменять порядок строк, проверить
    +   значения из item'ов
    +   выражения должны работать тоже
    +   row.enabled
    +   column.enabled+
        +   когда столбец исчезает, остаются "сопли" из views (default + visual + expressions,
            по 3 штуки на каждый) - что делать?! - "возвращение" обратно не дает эффекта
            
            X   скорее всего бочина с default view            
            X   количество лишних views возврастает с каждым комбо disabled/enabled
            X   this is not the way
            +   не удалялись элементы-ячейки
               
    +   cellClassName
    +   column.visible
    +   проверить соответствие между тем, что в таблице, и тем, что в html-е (с учетом :visible)
        
    +   отдельные тесты для view (учесть, что структура, возможно, поменяется...
        а тогда как быть? брать только values?)

?   cell: добавить свойства rowIndex, visibleRowIndex, colIndex

?   Сделать, чтобы элементу можно было назначать view по умолчанию

    А если я просто запилю какой-то view в callback'е и привяжу его к элементу?    

>   Этап 2 (февраль) // s@02.02
    
    >   editor (возможность делать прототипы editor'ов в колонках, плюс возможность
        сделать event, который генерирует editor'ы)
        
        -   у нас есть две модели редактора: общий (таскаем туда-сюда), фабрика (создаем/уничтожаем)
        -   общий подразумевает, что не может быть одновременно бесконечного кол-ва редакторов
            (плюс два редактора по умолчанию одновременно)
            
        -   есть две модели процесса редактирования: modal и instant. Modal: нам нужно 
            confirm/cancel, и только тогда применяется значение.
            Может, сделать отдельный компонент "cellEditor", который бы обрабатывал такие вещи?
        
        -   table.defaultEditor, потому что заёб прописывать для каждой ячейки
        -   для хитро выделанных: возможность определять html где-то вне json'а, а то
            builderSource это мрак (нужны ссылки на глобальные элементы... блин...)
            {builderSource: {copyHtml: 'jquerySelector'}}
        -   возможность устанавливать значение
            -   cell.editable
            -   setValue() устанавливает значение свойства item'а или expression
            -   попытка setValue() для cell с source, которое не editable, выводит warning
                в консоль

    >   activeRow, activeColumn, activeCell (может быть только одна)
        -   корректная работа с фокусом. syncFocusAndCell; если нет, то хотя БЫ
            после закрытия редактора таблица должна фокусироваться (а так - активная ячейка;
            например, при фокусировке таблицы фокус тут же должен переходить к активной
            ячейке)
            
            -   Amm.View.Html.Focusable, Amm.Trait.Focusable
            -   Amm.Table.Table.syncActiveFocus
            -   Пофиксить баг, когда .focus() не выставляет фокус на самом деле
                (focusDelay в View?)
            
    -   selection
        -   Amm.Selection.selectRange (startItem, endItem, replace: bool, mode: add|remove|revert)
        -   selectedRows
        -   selectedItems (может быть больше, так как часть rows может быть не active)
        -   корректная работа с shift-click
        
    -   Amm.View.Html.Table.SimpleBehaviour - простейший View для работы с клавиатуры
        (действует с редактором тоже)

-   Задачи, не распределенные по этапам
    -   currentEditingCell: менять при фокусировке редактора (если несколько редакторов открыто)
    -   activeRow/activeColumn: когда удаляется либо скрывается активная строка либо столбец,
        делать активным следующий
        
            -   preserveActivePos
        
            1) active row must be visible & enabled
            2) active column must be visible & enabled

            active row: observe "enabled", visible, displayParent, cleanup event
            active column: observe "enabled", visible, cleanup

            cell can be activated if it is both in "activatable" row & column        
        
-   Этап 3 (февраль-март)

    -   контекстное меню (seriously?!) с возможностью включать/выключать столбцы
        -   контекстное меню это жесть... тут без бутстрапа не сделаешь! а надо тянуть бутстрап 
            -   в базовом варианте сделаем на popper (https://popper.js.org/)
        -   нужно ActionList, наверное
    -   перетягивание столбцов
    -   resize столбцов
    -   прототипы контекстного меню строки, столбца (?), ячейки (?)
    -   в контекстном меню строки добавить опции "select this, select to this"
    
    
-   Этап 4 (март-апрель)
    -   ArrayMapper.Multiple extends ArrayMapper
    -   вспомогательные строки: belowActive, aboveActive, row.below, row.above
    -   возможность рисовать "ящик" под активной строкой, в который вставлять подтаблицу
    
-   Этап 5
    -   улучшить интеграцию с Amm.Data.Collection, которая к тому времени должна быть ок


    
2021-02-16
==========

