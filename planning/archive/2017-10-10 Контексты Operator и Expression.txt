2017-10-10 - Контексты Operator и Expression

Планирование множественных контекстов для Operator и Expression

?   Нужен ли нам _идентификатор_ контекста?

-   Operator: 

        getContextId()
        setContextId($id)
        deleteContext() <- удаляет текущий контекст?
            -   а что будет, если мы будем взаимодействовать с оператором, контекст которого удален?
        deleteContext($id)?
        
    -   Amm.Expression.ContextTag
            -   ContextTag: __TRAIT__
            -   contextId: $id

    -   Передается в качестве последнего параметра к входящим событиям (а)
        или в виде декторатора событий (б) -- более предпочтительно, потому что
        лучше подходит для данной роли и такое способ продолжает и дальше 
        пользоваться Amm.WithEvents.invokeHandlers() - я же зачем-то декораторы
        делал?!!
        
    -   кстати, можно добавить в invokeHandlers параметр 'defaultDecorator'
    
    -   Когда Operator обращается к операнду или предку, он должен передать 
        ему тот же самый contextId. Но это гемор!!
        
        Вариант Б: 
        
        -   перед любыми вычислениями мы смотрим contextId предка и, если он 
            отличается, синхронизируемся
            
            -   а как же bubbling? если уведомление передано операнду, и он 
                его обрабатывает?
            
2017-10-11

оператор:
    -   создаём контекст -> получаем девственно чистый оператор, как в момент инициализации.
        Связи с parent, expression, операндами остаются. Операнды-константы остаются прежними.
        Операнды-операторы могут принимать другие значения, поскольку в контексте могут быть
        другие _переменные_.
        
    -   идентификатор контекста передается при подписке на события!
    
    -   признак "некешируемости": мы храним список контекстов, в которых оператор некешируем,
        и checkForChanges() проверяет их в цикле
        
когда срабатывает событие с меткой контекста (ContextTag), у Expression устанавливается 
CurrentContextIds
        
        Expression.CurrentContextIds := 'parentContext childContext subChildContext'
        
        Expression.CurrentContextIds, ContextTag.contextIds -> contextIds.join(' ')
        
        идентификатор контекста включает в себя идентификаторы контекстов всех предков,
            в которых те находятся на момент создания контекста
            (это строчка через пробелы, чтобы облегчить поиск)

    -   значение убирается снимается в конце обработки события
    
    -   если в ходе обработки придет еще одно событие, то оно попадает в очередь
        и сработает ТОЛЬКО после того, как обработка предыдущего завершится. Поскольку
        наше дерево может находиться одновременно только в одном контексте!
        
        (TODO)
        
    -   если оператор производит любые вычисления либо получает уведомление от потомка об
        изменении, - если у нас есть контексты, то мы:
            -   смотрим Expression.CurrentContextId
            -   если среди них есть наш, то переключаемся в него
            -   если нет, то work as usual
            
    -   это оптимальный вариант частичного переключения контекста
    
ВОПРОС, который я пока не решил

    -   как range объединяет контексты потомков в единый массив??
        -   вариант: сделать метод evaluateAllContexts(), который проходит
            по всем вычисленным/не вычисленным (если не полное вычисление)
            контекстам, а/ля checkForChanges
            
        -   поскольку в этот момент у предка стоит _isEvaluating, то событие
            по изменению его значения не будет изменяться большое кол-во раз
            
        -   получается у нас есть
            range (без контекста) - вызывает rangeIterator.evaluateAll(), чтобы
                получить значение
                
                -> rangeIterator (с контекстом, с переменными) 
                -> operator (с контекстом, берет местные переменные у rangeIterator)
                
2017-10-14

Контексты мне позволят использовать одно и то же откомпилированное выражение 
для работы с несколькими this или наборами объектов

    !   thisObject передается в виде значения и не может входить в контекст!
        Это неправильно!

Реализация контекстов

    +   сделать thisObject переменной 
        +   это НЕ переменная, но thisObject является частью контекста! (при создании контекста
            меняется) - а значит, его должен возвращать оператор наподобие Var
        +   переименовать thisObject в expressionThis
        
        
    +   возможность хранить переменные НЕ в expression, а в других операторах 
        // done 2017-11-05
        +   Amm.Operator.isVarsProvider()
            +   сообщает expression, что его vars change
            X   если появляется предок с таким значением, то вызывается rebuildVarsChain() по всем
            X   Amm.Expression.notifyVarsChange(value, oldValue, varName, provider) - указывается provider!
        X   Amm.Operator.varsChange
        +   тесты
            +   цепочка: одно промежуточное звено
                +   изменение одной локальной переменной
                +   изменение нескольких локальных переменных
                +   изменение переменной предка
            +   цепочка: два промежуточных звена
                +   то же самое, но с учетом предка/корня
                
    +   возможность задавать декоратор по умолчанию для всех вызовов, которые осуществляются
        Amm.WithEvents.invokeHanlders (этот декоратор будет осуществлять переключение
        в нужный контекст)
       
    >   идентификатор контекста - объект
    
        ** идентификатор контекста - объект **
    
    -   создание, удаление, переключение контекста
        -   удаление контекста при cleanup thisObject?
        -   убедиться, что могут одновременно быть кешируемые и некешируемые контексты
    -   expression: возможность поставить входящие события в очередь
    -   распространение контекстов
    -   сделать пробный оператор для range
    
    -   сделать оператор для range
    
    -   ?   -   поддержка json в expressions? - а как быть, если у нас в объекте есть выражение, и оно меняется?
    
2017-11-12

контекст оператора

    оператор      >     оператор      >     оператор      >     оператор
    контекст      >                         контекст
    
    context parent: тот, у которого создавался контекст
    
    если у меня есть потомок, и я в нем создаю контекст, его контекст является потомком контекста
        context parent'а
        
    и если я в него вхожу, то предок войдет в контекст-предок
    но!! как быть, если есть событие у _предка_, и ему передается значение контекста?
        ведь мы не знаем значения контекстов для потомков. Куда переключать?
        
        1)  нужен пример такого случая
        2)  а может быть, в этом случае надо перевычислять все контексты-потомки?
            может, это произойдет автоматически?
            
        простейший пример это
            а)  range внутри range
            б)  range внутри shared expression
        
        context <-> parent context
                <-> owner operator
                
        
2017-11-14            
                
    operator.hasOwnContexts()
    operator.hasOwnContext(x)
    operator.setContext(ctx)
    
    
    part of context

    -   everything except
        -   operands (constants and operators)
        -   members beginning with UPPERCASE
        -   functions defined in prototype
        -   _contextId
        -   _contexts
        -   _ownContexts

    -   _contextId
    -   getContext()
    -   _contexts
    -   _ownContexts: { id: _context }
    
    Operator additional methods:
    -   createContext()
    -   getOperator(operand) - if operand is null, then parent is returned
        -   propagates context to returned operator
    ?   -   first-time context propagation
    ?   -   data to fill when context is destroyed?
    
    
    Amm.Expression._contexts = {
        id: context        
    }
    
2017-11-22

    Amm.Expression.subscribeOperator: у нас проблемы?
    
    1) нам надо отказаться от использования withEvents.invokeHandlers и написать свой вариант,
        у которого последний аргумент - это id контекста
    2) id контекста дописывается expression'ом автоматически
    3) при вызове обработчиков мы автоматом переводим их в нужный контекст
    4) мы полностью отказываемся от самостоятельной подписки на события и всё делаем через expression
    
2017-11-25

    Задачи
    
    -   проверить создание, удаление, переключение контекста (пока не распространение!)
    -   подписка с идентификаторами контекстов на события Expression
        -   техническая возможность
        -   убрать везде прямую подписку на события объектов
    -   переключение контекста при получении события
    -   распространение контекста
        -   плоское - тот, кто получает событие, может переключиться в тот же контекст
        -   когда количество контекстов не совпадает:
            
            this.items{{$item: this.selectedCurrency == $item.currency}}
            
            this.selectedCurrency находится во внешнем контексте по отношению к оператору сравнения,
                у которого множество контекстов (1/элемент), и если this.selectedCurrency меняется,
                то должен быть пересчитан каждый элемент. 
                
            Тут есть два варианта: 
            
                делать столько же контекстов у потомков, сколько и у предка; 
                тогда this.selectedCurrency будет подписано на переменные выражения много раз
    -   как быть с некешируемыми операторами? они должны пересчитываться на каждом tick'е. То есть
        hasNonCacheable должно учитывать еще и некешируемые контексты.
    -      
        
    test-case
        1   -   expression, multiple contexts
        2   -   range + parent context reference
        3   -   expression E + range A ref E + range B ref A, E

2017-11-26

+   сделать диспетчеризацию событий
+   сделать все события через event
+   пройтись по конструкторам и вынести константы в общие параметры
+   создание нового контекста: 
    для всех операндов, которые не являются операторами
        +   если у нас операнд WithEvents, мы вызываем eventsMethod _<Foo>Events(),
            вызываем changeMethod _<Foo>Change()
+   распространение контекста: если он есть у предка, то мы переходим в него
i   оптимизировать операнды-константы и ссылки на общие объекты и массивы будем тогда,
    когда хоть что-то вырисуется
    
2017-12-06

+   посмотреть, как будет работать один expression, который ссылается на один объект из двух
    контекстов
+   cleanup: 
    +   должно отписываться от наблюдаемых объектов
    +   оптимизация: expression должен вести учет всех наблюдаемых объектов сам, а потом
        отписываться от них
+   посмотреть вариант с частично кешируемыми выражениями
+   посмотреть вариант с некешируемыми выражениями
+   partial cleanup (какбе) 
-   сделать range со множеством контекстов, посмотреть, что получится [...]
+   удаление контекста при уничтожении объекта??

2017-12-25

Сделать range со множеством контекстов, посмотреть, что получится

+   базовая реализация: индекс + объект, либо только объект
    +   сделать, чтобы создавался range (тот самый) при парсинге
    +   range состоит из двух операторов: внешнего и внутреннего (итератора)
    +   RangeIterator extends VarsProvider, и у него есть множество контекстов
    +   сбор результатов
        +   значение по умолчанию - пустой массив
        +   исправить множественное valueChange
    +   Range наблюдает свой операнд (массив) и корректирует содержимое
        +   менять индексы элементов в правой части массива
        +   создавать новые или удалять лишние
    +   Тесты
        +   функция проверки корректности после операции 
        +   вставка нескольких элементов
        +   удаление нескольких элементов
        +   удаление > вставка
        +   удаление < вставка
        +   удаление = вставка
        +   замена source (частично пересекаются)
        +   перемешать элементы
        +   замена source (те же элементы)
        +   замена source (полностью другие элементы)
        +   замена source (частично пересекаются)
+   реализация: проверить условие на индекс
+   реализация: проверить условие на индекс + объект
+   проверить работу с функцией
    новая функция - не f(expression, value), а f(env, value)
        для varsProvider это еще f(env, value, varsOverride)
        env это { vars, expressionThis }
        expression.toFunction() содержит ссылку на свой expression
+   дополнительные range для разных случаев
    +   index, 
    +   all,
    +   slice
        +   тест
    +   index/all + component/child
        +   тест
    +   regExp
        +   тест
        +   функция
    +   корректно парсить и интерпретировать
        x   this->[] - все дети
        ?  this->{*} - то же самое
        ?   this->{range} - часть детей
        X   проверить - вроде должно
            !   нет. Сейчас операторы childElement, scopeElement, componentElement расчитаны на 
                наличие id и совпадение с ним, если id задан. Чтобы возвращать все, надо 
                переделывать и traits, и операторы.
        +   добавить поддержку
            +   все componentElement - немного тестировал
            +   все scopeElement - без тестов
            +   все childElement - без тестов
    +   тесты парсинга range, которые сейчас закомментированы
+   тест range condition, когда у expression несколько контекстов

2018-01-08 // done on 2017-02-08

+   Баг: VarsProvider при создании нового контекста не подписывает его на предка!
+   Пофиксить баг с множественным Range.Condition::valueChange (по одному разу на добавленного
    (и удаленного?) члена в результате),
+   Пофиксить баг с Range.Condition::valueChange([], [])
+   Вообще отказаться от объектов context с какой-либо начинкой? Необходимую информацию можно
    хранить и в самих операторах и их состоянии
+   Когда мы создаем новый контекст и выставляем в нём значения операндов, на каждое выставление
    идет reportChange, при этом вызывается громадная цепочка событий (не обязательно нужная!)
+   проверить, почему локальная переменная (цикла) оказывается среди переменных expression
+   Все события, касающиеся изменений vars, нужно подписывать напрямую, 
    и передавать интеллигентно, с учетом контекстов и используемых переменных, 
    а не транслировать всем через Expression. Иначе возникает лишняя нагрузка. 

