Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2022-02-21T09:25:00+02:00

====== Amm.Builder ======
Created Monday 21 February 2022

Amm.Builder это класс, который ищет опции элементов и их представлений в атрибутах DOM, и создает экземпляры элементов и/или представлений.

===== Интерфейс =====

==== Конструктор ====
Amm.Bulder = function([selector, ][options])
* selector: корневой узел или корневые узлы, откуда начинаем сканирование (CSS-селектор, либо объект jQuery с узлами)
* options: устанавливаем свойства Builder-а

==== Свойства ====
* **selector** - описан выше - узлы верхнего уровня, с которых начать сканирование
* **reportMode** - как сообщать о проблемах; битовая маска; по умолчанию PROBLEM_CONSOLE | PROBLEM_HTML (то есть и то, и то):
	* Amm.Builder.PROBLEM_SILENT - никак
	* Amm.Builder.PROBLEM_CONSOLE - писать warning в консоль
	* Amm.Builder.PROBLEM_HTML - создавать атрибут data-amm-warning в проблемных узлах
* **sel**: какие узлы в узлах верхнего уровня анализировать на предмет опций для элементов и представлений. По умолчанию это все узлы с атрибутами **data-amm-id**, **data-amm-e**, **data-amm-v**, **data-amm-x**.
* **selIgnore**: какие узлы (внутри узлов верхнего уровня) игнорировать. По умолчанию, это все элементы с атрибутами **data-amm-dont-build** и их потомки, элементы с атрибутами **data-amm-built** и **data-amm-iid** (или см. Amm.domHolderAttribute)
* **topLevelComponent**:  Amm.Element либо 'root'; null - всем "элементам верхнего уровня" (что это такое? тем, у которых нет компонента? Или тем, которые не созданы внутри других элементов?) устанавливать указанный компонент-владелец ('root' означает, в качестве владельца будет указываться Amm.Root)
* **rememberElements**: boolean; false - добавлять ли в массив elements все элементы
* **elements**: Array - заполняется, если rememberElements включен
* **topLevel**: Array - всегда заполняется "элементами верхнего уровня"
* **rememberProblems**: boolean; false заполнять ли сообщения об ошибках в this.problems
* **problems**: Array - реестр ошибок (заполняется, если включен rememberProblems)

==== Методы ====

=== calcPrototypes: function() ===
Сканирует дерево, но вместо самих элементов возвращает их "прототипы" (хеши options с классами). Эквивалентно this.build(true)

=== calcViewPrototypes: function(forElementOrPrototype) ===
Сканирует дерево конкретно для поиска "прототипов" представлений. Вовзращает Array с нулем или несколькими "прототипами". Если forElementOrPrototype заполнен, то оттуда будет взято **id**, чтобы выделить только views, относящиеся к данному id, и игнорировать другие. **Ведет себя так, как будто узлы в selector'е находятся внутри узла, общего для данного элемента.**

=== build: function(prototypesOnly) ===
Сканирует дерево, возвращает или элементы, или их "прототипы" (если prototypesOnly == TRUE).

=== clear() ===
"Сбрасывает" переменные свойства Bulder'а (elements, topLevel, problems) в первоначальное состояние

===== Принцип работы =====
* находит
* создает
* бла-бла-бла
* чтобы builder'ы не мешали друг другу

===== Особенности "Amm json" =====
* Во-первых, это "relaxed json": комментарии, одинарные и двойные кавычки; кавычки в ключах и простых значениях необязательны
* если объект создается при помощи Amm.dom(), то данные и экземпляры передаются напрямую (без перевода в json и обратно)
* $ext: можно подставить любой глобальный объект (указывается путь, начиная с window)
* $ref: можно дать ссылку на узел относительно данного узла DOM

===== Способы задать связь между view и element =====

==== При помощи иерархии DOM ====
**Элементы и представления "верхнего уровня": что это //вообще// такое?**

==== При помощи data-amm-id ====
id может быть использован
* локальный
* глобальный (с "@")
* __parent - спецзначение, означает "элемент, относящийся к узлу, внутри которого данный узел"

==== При помощи Amm.Builder.Ref ====

===== Смысл атрибута amm-element-id или свойства "id" элемента =====

===== Когда задействуется Builder =====
* при инициализации Amm
* если в конструкторе элемента есть определение, заданное при помощи DOM
	* в т.ч. строка, которая похожа на HTML-код, или объект jquery
	* builderSource
* если getDefaultViews вовзращает DOM

===== Особенности создания элементов и представлений =====

В Amm элементы не обязательно должны иметь представления, и эти представления (Views) не обязательно должны иметь соответствующие узлы DOM. Хотя в базовой реализации, как правило, так и есть - большинство применяемых на практике Views являются наследниками "частичного" класса Amm.View.Html.

Что касается Html views, то элемент может иметь представления, разбросанные по всему DOM, они не обязательно должны быть сгруппированы где-то вместе в дереве. Поэтому в некоторых случаях у элемента может не быть одного внешнего узла DOM.

В Amm элемент не должен "знать" о своих представлениях (несмотря на созданные для удобства методы вроде Amm.Element.prototype.findView() и используемый в "виджетах" метод constructDefaultViews(); представления подписываются на элемент и наблюдают его свойства, и, в большинстве случаев, никак не знают друг о друге и не взаимодействуют друг с другом. Исключение - случаи, когда views должны управлять общим уникальным ресурсом, вроде фокуса в input'ах: если у одного поля есть несколько views, и может быть фокус, то фокус должен быть у одного и только одного view.

У Views есть требования к классу, интерфейс, а следовательно, наличию тех или иных Traits элементов. Большинство Trait не имеют смысла без соответствующего View (хотя, являясь частью элемента, обычно "не знают" о views), и View, расчитанный на определенный интерфейс, вроде Field, не будет работать без Traits, его реализовывающих. Поэтому все объявления приходится делать в парах: добавлять элементу и соответствующий view, и соответствующий trait. Поскольку некоторые View подразумевают только один вид Trait, то у views (любых) есть метод getSuggestedTraits(), который "предлагает" Builder'у добавить те или иные Traits элементу при создании.

Формально создание элементов осуществляется так:
* создается экземпляр элемента вместе с Traits
* создаются Views, которые получают и ссылки на экземпляр элемента, и ссылки на DOM-узлы.

Для удобтва в конструкторе элемента можно предоставить ключ views с "прототипами" или экземплярами views, которые будут ассоциированы с элементом в конце работы конструктора.

Но, несмотря на то, что для работы View нужны и элемент, и dom-узел, их оба можно предоставить уже после создания самого view. Плюс, их можно менять (можно "отключить" view от одного элемента и назначить другому, то же самое с dom-узлами), хотя это обычно не делается; плюс view теоретически может какое-то время существовать без элемента - он просто не будет обновляться.

На практике есть несколько способов создания элементов, а именно:
* View first: сначала определяются узлы DOM, которые относятся к views одного и того же елемента; создаются views; после их опроса определяются, какие нужны traits; создается элемент с нужными traits и options
* Element first: создаем экземпляр элемента, вызываем его constructDefaultViews, затем создаем views. В этом случае getDefaultTraits() не используется, в опциях конструктора нужно сразу указывать Traits
